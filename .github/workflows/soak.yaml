name: Soak Test (Real MQTTâ†’Kafka via Compose)

on:
  workflow_dispatch:
  push:
    branches: [ "main", "sounds-ruth", "ruthhermelin/soak" ]

jobs:
  soak:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      ARTIFACT_DIR: artifacts
      SOAK_DURATION_SEC: "120"  
      SOAK_RATE_PER_SEC: "1000"  
      MQTT_TOPIC: "mqtt/soak"   
      KAFKA_TOPIC: "dev-robot-alerts"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare artifacts dir
        run: mkdir -p "$ARTIFACT_DIR"

      - name: Show Docker versions
        run: |
          docker --version || true
          docker compose version || true

      - name: Create dummy MinIO env file (for CI)
        run: |
          mkdir -p storage_with_mqtt/storage/combined_minio_setup
          cat > storage_with_mqtt/storage/combined_minio_setup/.env <<'EOF'
          MINIO_ROOT_USER=minioadmin
          MINIO_ROOT_PASSWORD=minioadmin123
          EOF

      - name: Start core stack
        run: docker compose up -d kafka mosquitto connect

      - name: Wait for Kafka & Mosquitto & Connect
        run: |
          set -e
          echo "== Wait Kafka =="
          for i in $(seq 1 60); do
            s=$(docker inspect -f '{{.State.Health.Status}}' kafka || echo unknown)
            [ "$s" = "healthy" ] && break
            echo "Kafka: $s ($i/60)"; sleep 3
          done
          [ "$(docker inspect -f '{{.State.Health.Status}}' kafka)" = "healthy" ] || { echo "Kafka not healthy"; exit 1; }

          echo "== Wait Mosquitto =="
          for i in $(seq 1 40); do
            s=$(docker inspect -f '{{.State.Health.Status}}' mosquitto || echo unknown)
            [ "$s" = "healthy" ] && break
            echo "Mosquitto: $s ($i/40)"; sleep 3
          done
          [ "$(docker inspect -f '{{.State.Health.Status}}' mosquitto)" = "healthy" ] || { echo "Mosquitto not healthy"; exit 1; }

          echo "== Wait Connect REST =="
          for i in $(seq 1 60); do
            if curl -sf http://localhost:8083/connectors >/dev/null; then break; fi
            echo "Connect REST not ready ($i/60)"; sleep 3
          done

      - name: Create Kafka topic if missing
        run: |
          set -e
          docker compose exec -T kafka bash -lc "\
            /opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list | grep -qx '${KAFKA_TOPIC}' \
            || /opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic '${KAFKA_TOPIC}' --partitions 1 --replication-factor 1"

      - name: Ensure MQTT source connector exists (points mosquitto -> ${KAFKA_TOPIC})
        run: |
          set -e
          cat > mqtt-source.json <<'JSON'
          {
            "name": "mqtt-source",
            "config": {
              "connector.class": "io.confluent.connect.mqtt.MqttSourceConnector",
              "tasks.max": "1",
              "mqtt.server.uri": "tcp://mosquitto:1883",
              "mqtt.topics": "mqtt/#",
              "mqtt.qos": "0",
              "clean.session": "true",
              "kafka.topic": "dev-robot-alerts",
              "key.converter": "org.apache.kafka.connect.storage.StringConverter",
              "key.converter.schemas.enable": "false",
              "value.converter": "org.apache.kafka.connect.converters.ByteArrayConverter",
              "value.converter.schemas.enable": "false",
              "errors.tolerance": "all",
              "errors.log.enable": "true",
              "topic.creation.enable": "false",
              "topic.creation.default.replication.factor": "1",
              "topic.creation.default.partitions": "1",
              "confluent.topic.bootstrap.servers": "kafka:9092",
              "confluent.topic.replication.factor": "1",
              "producer.override.bootstrap.servers": "kafka:9092"
            }
          }
          JSON
          if ! curl -sf http://localhost:8083/connectors/mqtt-source >/dev/null; then
            curl -sS -X POST -H 'Content-Type: application/json' --data @mqtt-source.json http://localhost:8083/connectors \
              || { echo "Connector create failed"; curl -s http://localhost:8083/connectors; exit 1; }
          fi
          curl -sSf http://localhost:8083/connectors/mqtt-source/status || true

      - name: Determine compose network name
        id: net
        run: |
          NET=$(docker network ls --format '{{.Name}}' | grep '_ag_cloud$' | head -1)
          echo "net=$NET" >> $GITHUB_OUTPUT
          echo "Using network: $NET"

      - name: Start Kafka consumer (kcat) on compose network
        run: |
          set -e
          NET="${{ steps.net.outputs.net }}"
          docker run --rm --name soak-kcat -i --network "$NET" edenhill/kcat:1.7.1 \
            -b kafka:9092 -t "${KAFKA_TOPIC}" -C -o end -q \
            > "${ARTIFACT_DIR}/kafka-received.log" 2> "${ARTIFACT_DIR}/kafka-consumer.err" &
          echo $! > kcat.pid
          sleep 3

      - name: Publish load to MQTT on compose network
        run: |
          set -euo pipefail
          NET="${{ steps.net.outputs.net }}"
          D=${SOAK_DURATION_SEC}
          RATE=${SOAK_RATE_PER_SEC}
          TOPIC=${MQTT_TOPIC}

          echo "Publishing D=$D sec, RATE=$RATE msg/s to $TOPIC"
          for sec in $(seq 1 "$D"); do
            echo "[$sec/$D] batch $sec"
            docker run --rm --network "$NET" alpine:3.20 \
              sh -lc "apk add --no-cache mosquitto-clients >/dev/null \
                && awk -v n=$RATE -v b=$sec 'BEGIN{for(i=0;i<n;i++)printf \"msg_%d_%d_%d\\n\", b, i, systime()}' \
                | mosquitto_pub -h mosquitto -p 1883 -t '$TOPIC' -l -q 0" \
              || echo "WARN: batch $sec failed"
            sleep 1
          done

      - name: Stop consumer and compute results
        run: |
          set -e
          sleep 20
          pkill -f soak-kcat || true

          D=${SOAK_DURATION_SEC}
          RATE=${SOAK_RATE_PER_SEC}
          SENT=$((D*RATE))
          RECEIVED=$(wc -l < "${ARTIFACT_DIR}/kafka-received.log" 2>/dev/null || echo 0)
          LOSS=$((SENT-RECEIVED))
          LOSS_PCT=$(awk -v s="$SENT" -v r="$RECEIVED" 'BEGIN{ if(s>0){printf "%.2f", (s-r)*100.0/s}else{printf "0.0"} }')
          echo "Sent: $SENT"
          echo "Received: $RECEIVED"
          echo "Lost: $LOSS ($LOSS_PCT%)"
          echo "{\"component\":\"mqtt-to-kafka\",\"sent\":$SENT,\"received\":$RECEIVED,\"loss\":$LOSS,\"loss_pct\":$LOSS_PCT}" \
            | tee "${ARTIFACT_DIR}/bridge.json"

      - name: Generate JUnit
        run: |
          python - <<'PY'
          import json, os, xml.etree.ElementTree as ET
          art = os.getenv("ARTIFACT_DIR","artifacts")
          thr = float(os.getenv("LOSS_THRESHOLD_PCT","1.0"))
          r = {"loss_pct":100.0}
          p = os.path.join(art, "bridge.json")
          if os.path.exists(p):
            with open(p) as f: r = json.load(f)
          ts = ET.Element("testsuite", name="mqtt-kafka-soak", tests="1")
          tc = ET.SubElement(ts, "testcase", classname="soak", name="mqtt->kafka")
          if float(r.get("loss_pct",100.0)) > thr:
            ET.SubElement(tc, "failure", message=str(r)).text = json.dumps(r)
            failures = 1
          else:
            failures = 0
          ts.set("failures", str(failures))
          os.makedirs(art, exist_ok=True)
          ET.ElementTree(ts).write(os.path.join(art, "junit.xml"), encoding="utf-8", xml_declaration=True)
          with open(os.path.join(art, "failures.txt"), "w") as f: f.write(str(failures))
          PY

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mqtt-kafka-soak-artifacts
          path: ${{ env.ARTIFACT_DIR }}
          retention-days: 7

      - name: Fail if tests failed
        if: always()
        run: |
          F=$(cat "$ARTIFACT_DIR/failures.txt" 2>/dev/null || echo 0)
          echo "Failures reported: $F"
          [ "$F" -gt 0 ] && exit 1 || echo "All good"

