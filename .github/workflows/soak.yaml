name: Soak Test (MQTT to Kafka Bridge)
on:
  workflow_dispatch:
  push:
    branches: [ "main", "sounds-ruth", "ruthhermelin/soak" ]
permissions:
  contents: read
  checks: write
  pull-requests: write
concurrency:
  group: soak-${{ github.ref }}
  cancel-in-progress: true
jobs:
  soak:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    defaults:
      run:
        shell: bash
    env:
      SOAK_DURATION_SEC: "150"
      SOAK_RATE_PER_SEC: "1000"
      LOSS_THRESHOLD_PCT: "1.0"
      MQTT_TOPIC: "soak/test"
      KAFKA_TOPIC: "dev-robot-telemetry-raw" 
      ARTIFACT_DIR: "artifacts"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Prepare artifacts dir
        run: mkdir -p "$ARTIFACT_DIR"

      - name: Build Kafka image
        run: docker build -t kafka-single:local mqtt_and_kafka/kafka

      # - name: Build Kafka image
      #   run: |
      #     cd kafka
      #     docker build -t kafka-single:local .

      - name: Copy kafka env file
        run: cp mqtt_and_kafka/kafka/kafka-files/kafka.env.example ./kafka.env.example
      # - name: Copy kafka env file
      #   run: |
      #     cp kafka/kafka.env.example ./kafka.env.example

      - name: Create docker-compose.yml & configs
        run: |
          cat > docker-compose.yml <<'YAML'
          services:
            kafka:
              image: kafka-single:local
              env_file:
                - mqtt_and_kafka/kafka/kafka-files/kafka.env.example
              environment:
                - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092
                - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
                - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=PLAINTEXT:PLAINTEXT
                - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=PLAINTEXT
                - KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR=1
                - KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR=1
                - KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
              ports:
                - "9092:9092"
                - "29092:9094"
              healthcheck:
                test: ["CMD", "/opt/bitnami/kafka/bin/kafka-topics.sh", "--bootstrap-server", "localhost:9092", "--list"]
                interval: 10s
                timeout: 5s
                retries: 40

            mosquitto:
              image: eclipse-mosquitto:2.0
              volumes:
                - ./mosquitto.conf:/mosquitto/config/mosquitto.conf:ro
              healthcheck:
                test: ["CMD", "mosquitto_pub", "-h", "localhost", "-t", "health", "-m", "test", "-q", "0"]
                interval: 5s
                timeout: 3s
                retries: 20
            mqtt-kafka-bridge:
              image: alpine:3.20
              depends_on:
                kafka:
                  condition: service_healthy
                mosquitto:
                  condition: service_healthy
              volumes:
                - ./bridge.py:/app/bridge.py:ro
              working_dir: /app
              environment:
                - MQTT_HOST=mosquitto
                - MQTT_PORT=1883
                - MQTT_TOPIC=soak/test
                - KAFKA_HOST=kafka
                - KAFKA_PORT=9092
                - KAFKA_TOPIC=${KAFKA_TOPIC}
              command: sh -c "apk add --no-cache python3 py3-pip py3-paho-mqtt py3-kafka || (apk add --no-cache python3 py3-pip && pip install --break-system-packages paho-mqtt kafka-python) && python bridge.py"
            mqtt-tools:
              image: alpine:3.20
              entrypoint: ["sh","-lc","sleep infinity"]
              depends_on:
                mosquitto:
                  condition: service_healthy
          YAML
          cat > mosquitto.conf <<'CONF'
          listener 1883 0.0.0.0
          allow_anonymous true
          persistence false
          CONF
          cat > bridge.py <<'PYTHON'
          import paho.mqtt.client as mqtt
          import time
          import os
          import json
          import threading
          import logging
          from kafka import KafkaProducer
          from kafka.errors import KafkaError
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)
          MQTT_HOST = os.getenv('MQTT_HOST', 'mosquitto')
          MQTT_PORT = int(os.getenv('MQTT_PORT', '1883'))
          MQTT_TOPIC = os.getenv('MQTT_TOPIC', 'soak/test')
          KAFKA_HOST = os.getenv('KAFKA_HOST', 'kafka')
          KAFKA_PORT = int(os.getenv('KAFKA_PORT', '9092'))
          KAFKA_TOPIC = os.getenv('KAFKA_TOPIC', 'dev-robot-telemetry-raw')
          messages_received = 0
          messages_sent = 0
          messages_failed = 0
          lock = threading.Lock()
          def create_kafka_producer():
              max_retries = 60
              for i in range(max_retries):
                  try:
                      producer = KafkaProducer(
                          bootstrap_servers=f'{KAFKA_HOST}:{KAFKA_PORT}',
                          value_serializer=lambda x: x.encode('utf-8') if isinstance(x, str) else x,
                          retries=3,
                          batch_size=16384,
                          linger_ms=10,
                          buffer_memory=33554432,
                          acks=1,
                          request_timeout_ms=30000,
                          api_version=(0, 10, 1)
                      )
                      logger.info("Kafka producer connected successfully")
                      producer.send(KAFKA_TOPIC, value="bridge_started").get(timeout=10)
                      return producer
                  except Exception as e:
                      logger.error(f"Failed to connect to Kafka (attempt {i+1}/{max_retries}): {e}")
                      time.sleep(2)
              raise Exception("Failed to connect to Kafka after max retries")
          kafka_producer = None
          running = True
          def on_connect(client, userdata, flags, rc):
              if rc == 0:
                  logger.info(f"MQTT connected successfully")
                  client.subscribe(MQTT_TOPIC, qos=0)
                  logger.info(f"Subscribed to MQTT topic: {MQTT_TOPIC}")
              else:
                  logger.error(f"MQTT connection failed with code {rc}")
          def on_message(client, userdata, msg):
              global messages_received, messages_sent, messages_failed, kafka_producer
              with lock:
                  messages_received += 1
              try:
                  if kafka_producer and running:
                      future = kafka_producer.send(KAFKA_TOPIC, value=msg.payload)
                      with lock:
                          messages_sent += 1
                      if messages_received % 5000 == 0:
                          logger.info(f"Bridge stats: MQTT received={messages_received}, Kafka sent={messages_sent}, failed={messages_failed}")
              except Exception as e:
                  with lock:
                      messages_failed += 1
                  logger.error(f"Error forwarding message to Kafka: {e}")
          def on_disconnect(client, userdata, rc):
              logger.warning(f"MQTT disconnected with code {rc}")
          def stats_reporter():
              while running:
                  time.sleep(15)
                  with lock:
                      logger.info(f"Bridge status - MQTT received: {messages_received}, Kafka sent: {messages_sent}, failed: {messages_failed}")
          def main():
              global kafka_producer, running
              logger.info("Starting MQTT to Kafka bridge...")
              logger.info(f"Config: MQTT={MQTT_HOST}:{MQTT_PORT}, topic={MQTT_TOPIC}")
              logger.info(f"Config: Kafka={KAFKA_HOST}:{KAFKA_PORT}, topic={KAFKA_TOPIC}")
              try:
                  logger.info("Creating Kafka producer...")
                  kafka_producer = create_kafka_producer()
                  logger.info("Setting up MQTT client...")
                  client = mqtt.Client(client_id="mqtt_kafka_bridge")
                  client.on_connect = on_connect
                  client.on_message = on_message
                  client.on_disconnect = on_disconnect
                  max_retries = 30
                  for i in range(max_retries):
                      try:
                          logger.info(f"Connecting to MQTT broker (attempt {i+1}/{max_retries})...")
                          client.connect(MQTT_HOST, MQTT_PORT, 60)
                          break
                      except Exception as e:
                          logger.error(f"Failed to connect to MQTT: {e}")
                          time.sleep(2)
                  else:
                      raise Exception("Failed to connect to MQTT after max retries")
                  stats_thread = threading.Thread(target=stats_reporter, daemon=True)
                  stats_thread.start()
                  logger.info("Bridge is ready and running...")
                  client.loop_forever()
              except KeyboardInterrupt:
                  logger.info("Bridge shutdown requested...")
              except Exception as e:
                  logger.error(f"Bridge error: {e}")
              finally:
                  running = False
                  if kafka_producer:
                      logger.info("Flushing Kafka producer...")
                      kafka_producer.flush(timeout=30)
                      kafka_producer.close()
                  logger.info(f"Bridge stopped. Final stats: MQTT received={messages_received}, Kafka sent={messages_sent}, failed={messages_failed}")
          if __name__ == "__main__":
              main()
          PYTHON

      - name: Show Docker/Compose versions
        run: |
          docker --version || true
          docker compose version || docker-compose --version || true

      - name: Start stack
        run: docker compose up -d

      # - name: Wait for services to be ready
      #   run: |
      #     echo "Waiting for Kafka to complete initialization..."
      #     # Wait for your app-start.sh to finish topics creation and smoke test
      #     for i in $(seq 1 120); do
      #       if docker compose logs kafka 2>/dev/null | grep -q "Bridge is ready and running\|✅ PASS\|Kafka starting"; then
      #         echo "Kafka initialization completed!"
      #         break
      #       fi
      #       echo "Waiting for Kafka initialization... ($i/120)"
      #       docker compose ps kafka
      #       docker compose logs kafka --tail=5
      #       sleep 2
      #     done
          
      #     echo "Waiting for bridge to be ready..."
      #     for i in $(seq 1 60); do
      #       if docker compose logs mqtt-kafka-bridge 2>/dev/null | grep -q "Bridge is ready and running"; then
      #         echo "Bridge is ready!"
      #         break
      #       fi
      #       echo "Waiting for bridge... ($i/60)"
      #       docker compose ps mqtt-kafka-bridge
      #       docker compose logs mqtt-kafka-bridge --tail=5
      #       sleep 2
      #     done
          
      #     echo "=== All Services Status ==="
      #     docker compose ps
      - name: Wait for services to be ready
        run: |
          echo "Waiting for Kafka to complete initialization..."
          for i in $(seq 1 120); do
            STATUS=$(docker compose ps -q kafka | xargs -r docker inspect -f '{{.State.Health.Status}}' || echo "unknown")
            if [ "$STATUS" = "healthy" ]; then
              echo "Kafka is healthy!"
              break
            fi
            echo "Waiting for Kafka initialization... ($i/120) status=$STATUS"
            docker compose ps kafka
            docker compose logs kafka --tail=5
            sleep 2
          done

          echo "Waiting for bridge to be ready..."
          for i in $(seq 1 60); do
            # הימנעי מאימוג'י; בדקי טקסט פשוט מהלוגים
            if docker compose logs mqtt-kafka-bridge 2>/dev/null | grep -qE "Bridge is ready and running|Bridge status - MQTT received"; then
              echo "Bridge is ready!"
              break
            fi
            echo "Waiting for bridge... ($i/60)"
            docker compose ps mqtt-kafka-bridge
            docker compose logs mqtt-kafka-bridge --tail=5
            sleep 2
          done

          echo "=== All Services Status ==="
          docker compose ps


      - name: Debug services connectivity
        run: |
          echo "=== Debugging services connectivity ==="
          echo "1. Container status:"
          docker compose ps
          
          echo "2. Testing MQTT connectivity:"
          docker compose exec -T mqtt-tools sh -c "
            apk add --no-cache mosquitto-clients netcat-openbsd
            echo 'Testing MQTT connection...'
            timeout 5 nc -zv mosquitto 1883 || echo 'MQTT port not reachable'
            echo 'Publishing test message to MQTT...'
            mosquitto_pub -h mosquitto -t test/debug -m 'test message' -q 0
            echo 'Subscribing to MQTT for 3 seconds...'
            timeout 3 mosquitto_sub -h mosquitto -t test/debug -q 0 || echo 'No messages received'
          "
          
          echo "3. Testing Kafka connectivity (using your custom image):"
          docker compose exec -T kafka bash -c "
            echo 'Testing Kafka connection...'
            /opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list
            echo 'Testing Kafka producer...'
            echo 'test message' | /opt/bitnami/kafka/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic ${KAFKA_TOPIC}
            echo 'Testing Kafka consumer (5 seconds)...'
            timeout 5 /opt/bitnami/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic ${KAFKA_TOPIC} --from-beginning || echo 'Done'
          "
          
          echo "4. Bridge detailed logs:"
          docker compose logs mqtt-kafka-bridge
          
          echo "5. Network connectivity from bridge:"
          docker compose exec -T mqtt-kafka-bridge sh -c "
            echo 'Testing from bridge container:'
            nc -zv mosquitto 1883 2>&1 || echo 'Cannot reach MQTT'
            nc -zv kafka 9092 2>&1 || echo 'Cannot reach Kafka'
            ps aux | grep python || echo 'No python process found'
          " || echo "Bridge container not accessible"

      - name: Install MQTT clients in tools container
        run: docker compose exec -T mqtt-tools sh -lc "apk add --no-cache mosquitto-clients jq busybox-extras"

      - name: Run MQTT to Kafka soak test
        run: |
          set -euo pipefail
          D=${SOAK_DURATION_SEC}
          RATE=${SOAK_RATE_PER_SEC}
          MQTT_TOPIC_VAR=${MQTT_TOPIC}
          KAFKA_TOPIC_VAR=${KAFKA_TOPIC}
          HOST=mosquitto
          PORT=1883
          SENT=$((D*RATE))
          
          echo "=== Starting MQTT to Kafka soak test ==="
          echo "Duration: $D seconds"
          echo "Rate: $RATE messages/second"
          echo "Total messages to send: $SENT"
          echo "MQTT Topic: $MQTT_TOPIC_VAR"
          echo "Kafka Topic: $KAFKA_TOPIC_VAR"
          
          echo "Starting Kafka consumer..."
          timeout $((D+120)) docker compose exec -T kafka bash -lc \
            "/opt/bitnami/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic ${KAFKA_TOPIC_VAR} --from-beginning" \
            > "${ARTIFACT_DIR}/kafka-received.log" 2> "${ARTIFACT_DIR}/kafka-consumer.err" &
          CONS_PID=$!
          
          sleep 5
          echo "=== Bridge status before test ==="
          docker compose logs mqtt-kafka-bridge --tail=5
          
          echo "=== Starting message sending ==="
          START_TIME=$(date +%s)
          for i in $(seq 1 "$D"); do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            echo "[$ELAPSED/${D}s] Sending batch $i/$D - $(date '+%H:%M:%S')"
            docker compose exec -T mqtt-tools timeout 10 sh -lc \
              "awk -v n=${RATE} -v batch=$i 'BEGIN{for(i=0;i<n;i++)printf \"msg_%d_%d_%d\n\", batch, i, systime()}' | mosquitto_pub -h ${HOST} -p ${PORT} -t ${MQTT_TOPIC_VAR} -l -q 0" || {
                echo "Warning: batch $i may have failed"
              }
            if [ $((i % 30)) -eq 0 ]; then
              echo "=== Bridge stats at ${i}s ==="
              docker compose logs mqtt-kafka-bridge --tail=3 | grep "Bridge stats" || echo "No stats yet"
            fi
            sleep 1
          done
          
          echo "=== Finished sending messages ==="
          END_TIME=$(date +%s)
          TOTAL_TIME=$((END_TIME - START_TIME))
          echo "Total sending time: ${TOTAL_TIME} seconds"
          
          echo "=== Final bridge status ==="
          docker compose logs mqtt-kafka-bridge --tail=10
          
          echo "Waiting for message processing to complete..."
          sleep 60
          
          echo "Stopping Kafka consumer..."
          kill $CONS_PID 2>/dev/null || true
          wait $CONS_PID 2>/dev/null || true
          
          echo "=== Calculating results ==="
          RECEIVED=$(wc -l < "${ARTIFACT_DIR}/kafka-received.log" 2>/dev/null || echo 0)
          LOSS=$((SENT-RECEIVED))
          LOSS_PCT=$(awk -v s="$SENT" -v r="$RECEIVED" 'BEGIN{ if(s>0){printf "%.2f", (s-r)*100.0/s}else{printf "0.0"} }')
          
          echo "=== SOAK TEST RESULTS ==="
          echo "Messages sent via MQTT: $SENT"
          echo "Messages received in Kafka: $RECEIVED"
          echo "Messages lost: $LOSS ($LOSS_PCT%)"
          echo "Test duration: ${TOTAL_TIME} seconds"
          
          echo "=== Sample of received messages ==="
          head -5 "${ARTIFACT_DIR}/kafka-received.log" 2>/dev/null || echo "No messages received"
          
          if [ -s "${ARTIFACT_DIR}/kafka-consumer.err" ]; then
            echo "=== Consumer errors ==="
            cat "${ARTIFACT_DIR}/kafka-consumer.err"
          fi
          
          echo "{\"component\":\"mqtt-to-kafka\",\"sent\":$SENT,\"received\":$RECEIVED,\"loss\":$LOSS,\"loss_pct\":$LOSS_PCT,\"duration\":$TOTAL_TIME}" \
            | tee "${ARTIFACT_DIR}/bridge.json"

      - name: Collect bridge logs
        if: always()
        run: |
          echo "=== Bridge Logs ===" > "${ARTIFACT_DIR}/bridge-logs.txt"
          docker compose logs mqtt-kafka-bridge >> "${ARTIFACT_DIR}/bridge-logs.txt" 2>&1 || true
          echo "=== All Container Logs ===" > "${ARTIFACT_DIR}/all-logs.txt"
          docker compose logs --no-color >> "${ARTIFACT_DIR}/all-logs.txt" 2>&1 || true

      - name: Generate JUnit report
        continue-on-error: true
        run: |
          python - <<'PY'
          import json, os, sys, xml.etree.ElementTree as ET
          loss_threshold = float(os.getenv("LOSS_THRESHOLD_PCT","1.0"))
          art = os.getenv("ARTIFACT_DIR","artifacts")
          os.makedirs(art, exist_ok=True)
          results = []
          p = os.path.join(art, "bridge.json")
          if os.path.exists(p):
            with open(p) as f:
              results.append(json.load(f))
          else:
            results.append({"component":"mqtt-to-kafka","sent":0,"received":0,"loss":0,"loss_pct":100.0,"error":"missing_result"})
          ts = ET.Element("testsuite", name="mqtt-kafka-soak", tests=str(len(results)))
          failures = 0
          for r in results:
            cname = r.get("component")
            loss_pct = float(r.get("loss_pct", 100.0))
            msg = f"{cname}: sent={r.get('sent')} received={r.get('received')} loss={r.get('loss')} ({loss_pct}%)"
            tc = ET.SubElement(ts, "testcase", classname="soak", name=cname)
            if loss_pct > loss_threshold or r.get("error"):
              ET.SubElement(tc, "failure", message=msg).text = json.dumps(r)
              failures += 1
            else:
              print(f":white_check_mark: {msg}")
          ts.set("failures", str(failures))
          ET.ElementTree(ts).write(os.path.join(art, "junit.xml"), encoding="utf-8", xml_declaration=True)
          with open(os.path.join(art, "failures.txt"), "w") as f:
            f.write(str(failures))
          if failures > 0:
            print(f":x: Test failed with {failures} failures")
            sys.exit(1)
          else:
            print(":white_check_mark: All tests passed!")
            sys.exit(0)
          PY

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mqtt-kafka-soak-artifacts
          path: ${{ env.ARTIFACT_DIR }}
          retention-days: 7

      - name: Publish JUnit results
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: ${{ env.ARTIFACT_DIR }}/junit.xml
          check_name: "MQTT to Kafka Soak Test Results"

      - name: Fail job if tests failed
        if: always()
        run: |
          F=$(cat "$ARTIFACT_DIR/failures.txt" 2>/dev/null || echo 0)
          echo "Failures reported: $F"
          if [ "$F" -gt 0 ]; then
            echo ":x: Tests failed!"
            exit 1
          else
            echo ":white_check_mark: All tests passed!"
          fi

      - name: Cleanup
        if: always()
        run: docker compose down -v || true