import os, uuid, json, logging
from typing import Any, Dict
from fastapi import FastAPI, HTTPException, Request, Body
from pydantic import BaseModel, ConfigDict, Field
from contextlib import asynccontextmanager

# from .models import Plan
import grpc
# from . import query_pb2, query_pb2_grpc  # generated by protoc
import query_pb2, query_pb2_grpc


RUNNER_ADDR = os.getenv("RUNNER_ADDR", "localhost:50051")
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

logging.basicConfig(level=LOG_LEVEL, format="%(asctime)s %(levelname)s %(name)s %(message)s")
log = logging.getLogger("gateway")


# ---------- Pydantic models ----------
class PlanModel(BaseModel):
    """
    Permissive plan model: validates that the top-level is an object and
    allows arbitrary keys (so your DSL can evolve).
    """
    model_config = ConfigDict(extra="allow")

    # If you want *some* shape, uncomment for a light assertion:
    ops: list[Any] | None = None

class RunResponseModel(BaseModel):
    requestId: str = Field(..., serialization_alias="requestId")
    jobId: str
    status: str
    detailsUrl: str = Field(..., serialization_alias="detailsUrl")

# ---------- FastAPI app ----------
    

@asynccontextmanager
async def lifespan(app: FastAPI):
    # --- startup ---
    channel = grpc.aio.insecure_channel(RUNNER_ADDR)
    stub = query_pb2_grpc.QueryRunnerStub(channel)
    app.state.channel = channel
    app.state.stub = stub
    log.info("gateway_startup (runner_addr=%s)", RUNNER_ADDR)

    try:
        yield  # the application runs here
    finally:
        # --- shutdown ---
        try:
            await channel.close()
        except Exception as e:
            log.warning("gateway_shutdown_error: %s", e)
        log.info("gateway_shutdown")
    
app = FastAPI(title="Query Gateway (FastAPI â†’ gRPC Runner)", lifespan=lifespan)


@app.post("/runQuery", response_model=RunResponseModel)
async def run_query(plan: PlanModel=Body(...), request: Request= None)->RunResponseModel:
    """Accepts the JSON plan, forwards it to the gRPC runner, returns job info."""

    request_id = request.headers.get("X-Request-Id", str(uuid.uuid4()))

    try:
        payload = json.dumps(plan.model_dump())

    except Exception as e:
        log.error("plan_serialization_error request_id=%s err=%s", request_id, e)
        raise HTTPException(status_code=400, detail="Invalid plan")


    log.info("run_query_received request_id=%s", request_id)

    try:
        # Propagate request id to runner as gRPC metadata
        metadata = (("x-request-id", request_id),)

        # Use the shared stub from app.state (created in lifespan)
        resp = await app.state.stub.RunQuery(
            query_pb2.Plan(json=payload),
            metadata=metadata,
        )

        result = {
            "requestId": request_id,
            "jobId": resp.jobId,
            "status": query_pb2.Status.Name(resp.status),#getattr(resp, "status", "SUBMITTED"),  # fallback if older stubs
            "detailsUrl": f"/jobs/{resp.jobId}",
        }
        log.info(
            "run_query_success request_id=%s job_id=%s status=%s",
            request_id,
            result["jobId"],
            result["status"],
        )
        return result
    
    except grpc.aio.AioRpcError as e:
        code = e.code()
        detail = e.details() or ""
        log.error(
            "runner_rpc_error request_id=%s code=%s detail=%s",
            request_id,
            code.name,
            detail,
        )
        if code == grpc.StatusCode.INVALID_ARGUMENT:
            raise HTTPException(status_code=400, detail=detail)
        if code == grpc.StatusCode.DEADLINE_EXCEEDED:
            raise HTTPException(status_code=504, detail="Runner deadline exceeded")
        if code == grpc.StatusCode.UNAVAILABLE:
            raise HTTPException(status_code=503, detail="Runner unavailable")
        raise HTTPException(status_code=502, detail=f"Runner error: {code.name} - {detail}")

    except Exception as e:
        log.exception("gateway_unhandled_error request_id=%s", request_id)
        raise HTTPException(status_code=500, detail="Internal server error")






