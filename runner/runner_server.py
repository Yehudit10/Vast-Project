import os, json, uuid, logging
from concurrent import futures
import grpc
# from . import query_pb2, query_pb2_grpc  # generated by protoc
import query_pb2, query_pb2_grpc


# -------- Config --------
RUNNER_MODE = os.getenv("RUNNER_MODE", "mock")  # "mock" or "real"
FLINK_REST_URL = os.getenv("FLINK_REST_URL", "http://flink:8081")  # example
PORT = int(os.getenv("PORT", "50051"))
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

# -------- Logging --------
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s %(levelname)s %(name)s %(message)s",
)
log = logging.getLogger("runner")

class QueryRunnerImpl(query_pb2_grpc.QueryRunnerServicer):
    def RunQuery(self, request, context):

        request_id = str(uuid.uuid4())  # you could also extract from metadata later
        log.info("RunQuery called request_id=%s mode=%s", request_id, RUNNER_MODE)

        # Validate the incoming JSON at least syntactically.
        try:
            plan = json.loads(request.json)
            log.info("Plan received request_id=%s keys=%s", request_id, list(plan.keys()))
        except Exception as e:
            log.error("Invalid plan JSON request_id=%s error=%s", request_id, e)
            context.abort(grpc.StatusCode.INVALID_ARGUMENT, "Invalid plan JSON")

        if RUNNER_MODE == "mock":
            job_id = f"mock-{uuid.uuid4().hex[:8]}"
            log.info("Mock job submitted request_id=%s job_id=%s", request_id, job_id)
            return query_pb2.RunResponse(jobId=job_id, status="SUBMITTED")

        # --- Real (sketch): translate plan â†’ Flink REST call(s) ---
        # try:
        #     sql = compile_plan_to_sql(plan)  # you implement this
        #     # Example for a SQL Gateway endpoint:
        #     # async with httpx.AsyncClient(timeout=10) as client:
        #     #     r = await client.post(f"{FLINK_REST_URL}/v1/statements",
        #     #                            json={"statement": sql})
        #     #     r.raise_for_status()
        #     #     data = r.json()
        #     #     job_id = data.get("operationId") or data.get("jobId", "unknown")
        #     # return query_pb2.RunResponse(jobId=job_id, status="SUBMITTED")
        # except httpx.TimeoutException:
        #     context.abort(grpc.StatusCode.DEADLINE_EXCEEDED, "Flink timeout")
        # except httpx.HTTPError as e:
        #     context.abort(grpc.StatusCode.FAILED_PRECONDITION, f"Flink error: {e}")
        log.warning("Real mode not implemented request_id=%s flink_url=%s", request_id, FLINK_REST_URL)
        context.abort(
            grpc.StatusCode.UNIMPLEMENTED,
            "RUNNER_MODE=real not implemented in this example",
        )



# -------- Server bootstrap --------
def serve(port: int = PORT):
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=8))
    query_pb2_grpc.add_QueryRunnerServicer_to_server(QueryRunnerImpl(), server)
    server.add_insecure_port(f"[::]:{port}")
    server.start()
    log.info("Runner gRPC listening on :%s (mode=%s)", port, RUNNER_MODE)
    server.wait_for_termination()

if __name__ == "__main__":
    serve()
