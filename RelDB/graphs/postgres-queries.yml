# Save as postgres-queries.yml
# Custom queries for postgres_exporter to expose WAL, replication lag, and BRIN stats.

pg_wal_stats:
  query: |
    SELECT wal_records, wal_fpi, wal_bytes
    FROM pg_stat_wal
  metrics:
    - wal_records:
        usage: COUNTER
        description: "Number of WAL records since startup"
    - wal_fpi:
        usage: COUNTER
        description: "Number of WAL full page images since startup"
    - wal_bytes:
        usage: COUNTER
        description: "Total WAL bytes generated since startup"

# On PRIMARY: lag in bytes per replica
pg_replication_lag_bytes_primary:
  query: |
    SELECT
      application_name,
      GREATEST(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn), 0) AS bytes_lag
    FROM pg_stat_replication
  metrics:
    - application_name:
        usage: LABEL
        description: "Replica application_name as seen from primary"
    - bytes_lag:
        usage: GAUGE
        description: "Replication lag in bytes (primary view)"

# On STANDBY: lag in seconds (returns a row only on standby)
pg_replication_replay_lag_seconds_standby:
  query: |
    SELECT
      EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) AS replay_lag_seconds
    WHERE pg_is_in_recovery()
  metrics:
    - replay_lag_seconds:
        usage: GAUGE
        description: "Replication replay lag in seconds (standby only)"

# BRIN index I/O and hit ratio per BRIN index
pg_brin_index_io:
  query: |
    SELECT
      s.schemaname,
      s.relname AS table_name,
      s.indexrelname AS index_name,
      s.idx_blks_read,
      s.idx_blks_hit,
      CASE
        WHEN (s.idx_blks_read + s.idx_blks_hit) > 0
          THEN (s.idx_blks_hit::float / (s.idx_blks_read + s.idx_blks_hit))
        ELSE NULL
      END AS brin_hit_ratio
    FROM pg_statio_user_indexes s
    JOIN pg_class i ON i.oid = s.indexrelid
    JOIN pg_am am ON am.oid = i.relam
    WHERE am.amname = 'brin'
  metrics:
    - schemaname:
        usage: LABEL
        description: "Schema"
    - table_name:
        usage: LABEL
        description: "Table"
    - index_name:
        usage: LABEL
        description: "BRIN index name"
    - idx_blks_read:
        usage: COUNTER
        description: "Index blocks read from disk for this BRIN index"
    - idx_blks_hit:
        usage: COUNTER
        description: "Index blocks found in cache for this BRIN index"
    - brin_hit_ratio:
        usage: GAUGE
        description: "Cache hit ratio for this BRIN index (0..1)"


# Active connections
pg_active_connections:
  query: |
    SELECT state, COUNT(*) as count
    FROM pg_stat_activity
    GROUP BY state
  metrics:
    - state:
        usage: LABEL
        description: "Connection state (active, idle, etc.)"
    - count:
        usage: GAUGE
        description: "Number of connections per state"

# Cache hit ratio per table
pg_table_cache_hit_ratio:
  query: |
    SELECT
      relname as table,
      heap_blks_read,
      heap_blks_hit,
      CASE
        WHEN (heap_blks_read + heap_blks_hit) > 0
        THEN (heap_blks_hit::float / (heap_blks_read + heap_blks_hit))
        ELSE NULL
      END as cache_hit_ratio
    FROM pg_statio_user_tables
  metrics:
    - table:
        usage: LABEL
        description: "Table name"
    - heap_blks_read:
        usage: COUNTER
        description: "Disk blocks read"
    - heap_blks_hit:
        usage: COUNTER
        description: "Cache hits"
    - cache_hit_ratio:
        usage: GAUGE
        description: "Cache hit ratio (0..1)"

# Database size
pg_database_size:
  query: |
    SELECT datname, pg_database_size(datname) as size_bytes
    FROM pg_database
  metrics:
    - datname:
        usage: LABEL
        description: "Database name"
    - size_bytes:
        usage: GAUGE
        description: "Database size in bytes"

# ============================================
# LEAF DISEASES METRICS
# ============================================

# Total leaf reports
leaf_reports_total:
  query: "SELECT COUNT(*)::float as total FROM public.leaf_reports"
  master: true
  metrics:
    - total:
        usage: "GAUGE"
        description: "Total number of leaf disease reports"

# Reports by disease type
leaf_reports_by_disease:
  query: |
    SELECT 
      COALESCE(ldt.name, 'Unknown') as disease_name,
      lr.leaf_disease_type_id::text as disease_id,
      COUNT(*)::float as count 
    FROM public.leaf_reports lr
    LEFT JOIN public.leaf_disease_types ldt ON lr.leaf_disease_type_id = ldt.id
    WHERE lr.sick = true
    GROUP BY lr.leaf_disease_type_id, ldt.name
  master: true
  metrics:
    - disease_name:
        usage: "LABEL"
        description: "Disease name"
    - disease_id:
        usage: "LABEL"
        description: "Disease type ID"
    - count:
        usage: "GAUGE"
        description: "Number of reports per disease"

# Reports by device
leaf_reports_by_device:
  query: |
    SELECT 
      device_id::text as device_id,
      COUNT(*)::float as total_reports,
      SUM(CASE WHEN sick THEN 1 ELSE 0 END)::float as sick_reports
    FROM public.leaf_reports
    GROUP BY device_id
  master: true
  metrics:
    - device_id:
        usage: "LABEL"
        description: "Device ID"
    - total_reports:
        usage: "GAUGE"
        description: "Total reports per device"
    - sick_reports:
        usage: "GAUGE"
        description: "Sick reports per device"

# Daily disease progression (time series)
leaf_disease_daily_progression:
  query: |
    SELECT 
      COALESCE(ldt.name, 'Unknown') as disease_name,
      lr.leaf_disease_type_id::text as disease_id,
      TO_CHAR(DATE_TRUNC('day', lr.ts), 'YYYY-MM-DD') as report_date,
      EXTRACT(EPOCH FROM DATE_TRUNC('day', lr.ts))::float as date_timestamp,
      COUNT(*)::float as sick_count
    FROM public.leaf_reports lr
    LEFT JOIN public.leaf_disease_types ldt ON lr.leaf_disease_type_id = ldt.id
    WHERE lr.sick = true
      AND lr.ts > NOW() - INTERVAL '365 days'
    GROUP BY lr.leaf_disease_type_id, ldt.name, DATE_TRUNC('day', lr.ts)
    ORDER BY date_timestamp DESC
  master: true
  metrics:
    - disease_name:
        usage: "LABEL"
        description: "Disease name"
    - disease_id:
        usage: "LABEL"
        description: "Disease type ID"
    - report_date:
        usage: "LABEL"
        description: "Report date (YYYY-MM-DD)"
    - date_timestamp:
        usage: "GAUGE"
        description: "Date timestamp for X axis"
    - sick_count:
        usage: "GAUGE"
        description: "Number of sick reports per day"

# Hourly disease detection (last 7 days)
leaf_disease_hourly_detection:
  query: |
    SELECT 
      COALESCE(ldt.name, 'Unknown') AS disease_name,
      lr.leaf_disease_type_id::text AS disease_id,
      -- השעה האחרונה שבה נמצאה המחלה (כעצם EPOCH)
      MAX(EXTRACT(EPOCH FROM DATE_TRUNC('hour', lr.ts)))::float AS hour_timestamp,
      -- כמות הגילויים (אפשר להשאיר ככה, או לכוונן להגדרה אחרת)
      COUNT(*)::float AS count
    FROM public.leaf_reports lr
    LEFT JOIN public.leaf_disease_types ldt ON lr.leaf_disease_type_id = ldt.id
    WHERE lr.sick = true
      AND lr.ts > NOW() - INTERVAL '7 days'
    GROUP BY lr.leaf_disease_type_id, ldt.name
    ORDER BY hour_timestamp DESC
  master: true
  metrics:
    - disease_name:
        usage: "LABEL"
        description: "Disease name"
    - disease_id:
        usage: "LABEL"
        description: "Disease type ID"
    - hour_timestamp:
        usage: "GAUGE"
        description: "Last detection hour (epoch)"
    - count:
        usage: "GAUGE"
        description: "Detections count in last 7 days"


# Disease severity by device (percentage)
leaf_disease_severity_by_device:
  query: |
    SELECT 
      COALESCE(ldt.name, 'Unknown') as disease_name,
      lr.leaf_disease_type_id::text as disease_id,
      lr.device_id::text as device_id,
      (SUM(CASE WHEN lr.sick THEN 1 ELSE 0 END)::float / COUNT(*)::float * 100) as sick_percentage
    FROM public.leaf_reports lr
    LEFT JOIN public.leaf_disease_types ldt ON lr.leaf_disease_type_id = ldt.id
    WHERE lr.ts > NOW() - INTERVAL '30 days'
    GROUP BY lr.leaf_disease_type_id, ldt.name, lr.device_id
    HAVING COUNT(*) > 5
  master: true
  metrics:
    - disease_name:
        usage: "LABEL"
        description: "Disease name"
    - disease_id:
        usage: "LABEL"
        description: "Disease type ID"
    - device_id:
        usage: "LABEL"
        description: "Device ID"
    - sick_percentage:
        usage: "GAUGE"
        description: "Percentage of sick reports (0-100)"


# ============================================
# ULTRASONIC PLANT PREDICTIONS METRICS
# S3 Path format: s3://sound/plants/microphone-MIC-02/2025-11-13/1763018877231/MIC-U-01_20251113T073457Z.wav
# ============================================

ultrasonic_predictions_total:
  query: "SELECT COUNT(*)::float as total FROM public.ultrasonic_plant_predictions"
  master: true
  metrics:
    - total:
        usage: "GAUGE"
        description: "Total number of ultrasonic predictions"

ultrasonic_predictions_by_class:
  query: |
    SELECT 
      CASE predicted_class
        WHEN 'Healthy_Tomato' THEN 'Healthy_Plant'
        WHEN 'Healthy_Tobacco' THEN 'Healthy_Plant'
        
        WHEN 'Drought_Tomato' THEN 'Drought_Plant'
        WHEN 'Drought_Tobacco' THEN 'Drought_Plant' 
        
        WHEN 'Pest_Tomato' THEN 'Pest_Plant'
        WHEN 'Pest_Tobacco' THEN 'Pest_Plant' 
        
        ELSE COALESCE(predicted_class, 'unknown')
      END as predicted_class,
      COUNT(*)::float as count 
    FROM public.ultrasonic_plant_predictions 
    GROUP BY 1 
  master: true
  metrics:
    - predicted_class:
        usage: "LABEL"
        description: "Predicted class (Drought_Plant, Healthy_Plant, Pest_Plant, Control, etc.)"
    - count:
        usage: "GAUGE"
        description: "Number of predictions per class"

ultrasonic_predictions_by_watering:
  query: |
    SELECT 
      COALESCE(watering_status, 'unknown') as watering_status, 
      COUNT(*)::float as count 
    FROM public.ultrasonic_plant_predictions 
    GROUP BY watering_status
  master: true
  metrics:
    - watering_status:
        usage: "LABEL"
        description: "Watering status (Yes, No, etc.)"
    - count:
        usage: "GAUGE"
        description: "Number of predictions per watering status"

ultrasonic_predictions_by_status:
  query: |
    SELECT 
      COALESCE(status, 'unknown') as status, 
      COUNT(*)::float as count 
    FROM public.ultrasonic_plant_predictions 
    GROUP BY status
  master: true
  metrics:
    - status:
        usage: "LABEL"
        description: "Record status (Success, Error, etc.)"
    - count:
        usage: "GAUGE"
        description: "Number of predictions per status"

ultrasonic_predictions_avg_confidence:
  query: |
    SELECT 
      AVG(confidence)::float as avg_confidence 
    FROM public.ultrasonic_plant_predictions 
    WHERE confidence IS NOT NULL
      AND TO_TIMESTAMP(
        SUBSTRING(
          REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
          FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
        ), 
        'YYYYMMDD"T"HH24MISS'
      ) > NOW() - INTERVAL '7 days' 
  master: true
  metrics:
    - avg_confidence:
        usage: "GAUGE"
        description: "Average confidence score of predictions (Last 7 days)"

ultrasonic_predictions_recent:
  query: |
    SELECT 
      COUNT(*)::float as recent_count
    FROM (
      SELECT 1 
      FROM public.ultrasonic_plant_predictions 
      ORDER BY prediction_time DESC 
      LIMIT 100
    ) sub
  master: true
  metrics:
    - recent_count:
        usage: "GAUGE"
        description: "Count of recent predictions (last 100)"

ultrasonic_confidence_by_sensor:
  query: |
    SELECT 
      SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_') as sensor_id,
      AVG(confidence)::float as avg_confidence,
      COUNT(*)::float as sample_count,
      MIN(confidence)::float as min_confidence,
      MAX(confidence)::float as max_confidence
    FROM public.ultrasonic_plant_predictions 
    WHERE status = 'Success'
      AND confidence IS NOT NULL
      AND file ~ 'MIC-U-\d+_\d{8}T\d{6}Z\.wav$'
    GROUP BY SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_')
    ORDER BY avg_confidence DESC
  master: true
  metrics:
    - sensor_id:
        usage: "LABEL"
        description: "Sensor ID extracted from file (e.g., MIC-U-01, MIC-U-02)"
    - avg_confidence:
        usage: "GAUGE"
        description: "Average confidence level per sensor"
    - sample_count:
        usage: "GAUGE"
        description: "Number of successful samples per sensor"
    - min_confidence:
        usage: "GAUGE"
        description: "Minimum confidence per sensor"
    - max_confidence:
        usage: "GAUGE"
        description: "Maximum confidence per sensor"

ultrasonic_daily_stress_count:
  query: |
    SELECT 
      DATE_TRUNC('hour', 
        TO_TIMESTAMP(
          SUBSTRING(
            REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
            FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
          ), 
          'YYYYMMDD"T"HH24MISS'
        )
      ) as event_time,
      EXTRACT(EPOCH FROM DATE_TRUNC('hour', 
        TO_TIMESTAMP(
          SUBSTRING(
            REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
            FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
          ), 
          'YYYYMMDD"T"HH24MISS'
        )
      ))::float as date_timestamp,
      COUNT(*)::float as event_count
    FROM public.ultrasonic_plant_predictions 
    WHERE predicted_class IN ('Drought_Tomato', 'Pest_Tomato')
      AND status = 'Success'
      AND TO_TIMESTAMP(
        SUBSTRING(
          REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
          FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
        ), 
        'YYYYMMDD"T"HH24MISS'
      ) >= DATE_TRUNC('day', NOW())
    GROUP BY DATE_TRUNC('hour', 
      TO_TIMESTAMP(
        SUBSTRING(
          REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
          FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
        ), 
        'YYYYMMDD"T"HH24MISS'
      )
    )
    ORDER BY date_timestamp DESC
  master: true
  metrics:
    - event_time:
        usage: "LABEL"
        description: "Hour of stress event extracted from file name"
    - date_timestamp:
        usage: "GAUGE"
        description: "Hour timestamp (Unix epoch)"
    - event_count:
        usage: "GAUGE"
        description: "Number of stress events per hour (Today)"

ultrasonic_success_rate_by_sensor:
  query: |
    SELECT 
      SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_') as sensor_id,
      SUM(CASE WHEN status = 'Success' THEN 1.0 ELSE 0.0 END) / 
        NULLIF(COUNT(*), 0) * 100.0 as success_rate
    FROM public.ultrasonic_plant_predictions 
    WHERE file ~ 'MIC-U-\d+_\d{8}T\d{6}Z\.wav$'
    GROUP BY SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_')
  master: true
  metrics:
    - sensor_id:
        usage: "LABEL"
        description: "Sensor ID"
    - success_rate:
        usage: "GAUGE"
        description: "Success rate percentage per sensor"

ultrasonic_class_distribution_healthy:
  query: |
    SELECT 
      COUNT(*) as healthy_count,
      COUNT(*) * 100.0 / 
        NULLIF((SELECT COUNT(*) FROM public.ultrasonic_plant_predictions WHERE status = 'Success'), 0) 
        as healthy_percentage
    FROM public.ultrasonic_plant_predictions 
    WHERE predicted_class IN ('Healthy_Tomato', 'Healthy_Tobacco', 'Control_Greenhouse', 'Control_Empty') AND status = 'Success'
  master: true
  metrics:
    - healthy_count:
        usage: "GAUGE"
        description: "Count of healthy plant predictions"
    - healthy_percentage:
        usage: "GAUGE"
        description: "Percentage of healthy plant predictions"

ultrasonic_class_distribution_stress:
  query: |
    SELECT 
      COUNT(*) as stress_count,
      COUNT(*) * 100.0 / 
        NULLIF((SELECT COUNT(*) FROM public.ultrasonic_plant_predictions WHERE status = 'Success'), 0)
        as stress_percentage
    FROM public.ultrasonic_plant_predictions 
    WHERE predicted_class IN ('Drought_Tomato', 'Pest_Tomato') AND status = 'Success'
  master: true
  metrics:
    - stress_count:
        usage: "GAUGE"
        description: "Count of stress plant predictions"
    - stress_percentage:
        usage: "GAUGE"
        description: "Percentage of stress plant predictions"

ultrasonic_confidence_distribution:
  query: |
    SELECT 
      CASE 
        WHEN confidence >= 0.9 THEN '90-100% (High)'
        WHEN confidence >= 0.75 THEN '75-90% (Good)'
        WHEN confidence >= 0.6 THEN '60-75% (Medium)'
        ELSE '< 60% (Low)'
      END as confidence_range,
      COUNT(*)::float as count
    FROM public.ultrasonic_plant_predictions 
    WHERE status = 'Success'
    GROUP BY confidence_range
    ORDER BY confidence_range DESC
  master: true
  metrics:
    - confidence_range:
        usage: "LABEL"
        description: "Confidence level range"
    - count:
        usage: "GAUGE"
        description: "Number of predictions in confidence range"

ultrasonic_sensor_activity_timeline:
  query: |
    SELECT 
      SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_') as sensor_id,
      TO_CHAR(DATE_TRUNC('day', 
        TO_TIMESTAMP(
          SUBSTRING(
            REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
            FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
          ), 
          'YYYYMMDD"T"HH24MISS'
        )
      ), 'YYYY-MM-DD') as activity_date,
      COUNT(*)::float as daily_readings
    FROM public.ultrasonic_plant_predictions 
    WHERE status = 'Success'
      AND file ~ 'MIC-U-\d+_\d{8}T\d{6}Z\.wav$'
    GROUP BY 
      SUBSTRING(REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') FROM '^(MIC-U-\d+)_'),
      DATE_TRUNC('day', 
        TO_TIMESTAMP(
          SUBSTRING(
            REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
            FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
          ), 
          'YYYYMMDD"T"HH24MISS'
        )
      )
    ORDER BY activity_date DESC, sensor_id
  master: true
  metrics:
    - sensor_id:
        usage: "LABEL"
        description: "Sensor ID"
    - activity_date:
        usage: "LABEL"
        description: "Activity date extracted from file name"
    - daily_readings:
        usage: "GAUGE"
        description: "Daily reading count per sensor"

ultrasonic_predictions_per_hour:
  query: |
    SELECT 
      EXTRACT(EPOCH FROM DATE_TRUNC('hour', 
        TO_TIMESTAMP(
          SUBSTRING(
            REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
            FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
          ), 
          'YYYYMMDD"T"HH24MISS'
        )
      ))::float as hour_timestamp,
      COUNT(*)::float as count
    FROM public.ultrasonic_plant_predictions
    WHERE TO_TIMESTAMP(
        SUBSTRING(
          REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
          FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
        ), 
        'YYYYMMDD"T"HH24MISS'
      ) >= DATE_TRUNC('day', NOW())
      AND file ~ 'MIC-U-\d+_\d{8}T\d{6}Z\.wav$'
    GROUP BY DATE_TRUNC('hour', 
      TO_TIMESTAMP(
        SUBSTRING(
          REGEXP_REPLACE(file, '^.*/([^/]+)$', '\1') 
          FROM 'MIC-U-\d+_(\d{8}T\d{6})Z'
        ), 
        'YYYYMMDD"T"HH24MISS'
      )
    )
    ORDER BY hour_timestamp DESC
  master: true
  metrics:
    - hour_timestamp:
        usage: "LABEL"
        description: "Hour timestamp (Unix epoch) extracted from file name"
    - count:
        usage: "GAUGE"
        description: "Predictions count per hour (Today's Events)"
